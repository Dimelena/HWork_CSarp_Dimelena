
// Seminar 8

// Цикличные процедуры делятся на два типа
// итеративные, основаны на итерациях, каждые из которых равносильны с предыдудущей (итерации) 
// и рекурсивыне, основанные на погружении, когда каждая последующая итерация погружается глубже в соседнюю
// в итеративных процедурах обязательно условие для существования цикла - цикл, в рекурсии - продолжение рекурсии
// пример рекурсии - матрешка, которую открывают одну за другой, пока не дошли до открываемой, 
// но потом сразу происходит обратный процесс - ее пошаговая сборка 
// погружение  и возврат
// действия на этапе погружения, возвращения


// Task 01

/*
void ShowNum(int num)               // в этом методе рекурсия происходит на этапе возвращения
{                                   // void завершает работу в том месте,где он был вызван,а вызван он был в строке if(num > 1..) 
    //Console.Write(num + " ");     // действия, которые выполняются до того, как метод вызовет сам себя, происходят при погружении
    if(num > 1) ShowNum(num - 1);    // рекур.метод вызывая сам себя обязательно должен отправлять аргумент, отличный от того,
    Console.Write(num + " ");        // чем является его собственный арг и в конце концов вызовет арг, который закончит рекурсию
}
ShowNum(5);
*/

// Task 02 

// Напишите программу, которая будет принимать на вход число и возвращать сумму его цифр

/*
int SumOfDigits(int num)
{
    if(num != 0) return SumOfDigits(num / 10) + num % 10;  // младший разряд метода берет свою цифру, а оставшееся число передаст следующему, тот возбмет св.цифру, оставшееся число передаст следующему 
    return 0;                                              // метод вызывает сам себя и должен иметь функционал 
}
Console.WriteLine(SumOfDigits(1234));
*/


// как это выглядит:
// f(1234) -> f(123) + 4 (четверку запомнил)
// f(123) -> f(12) + 3 (тройку запомнил)
// f(12) -> f(1) + 2 (двойку запомнил)
// f(1) -> f(0) + 1 (единицу запомнил)       
// f(0) -> 0                                            <- погружение в рекурсию, вернул 0 (до этого момента в оп.пам. 5 версий)
// f(1) -> 0 + 1 = 0 (прибавил 1, котрую он запомнил)   <- отсюда возвращение 
// f(12) -> 1 + 2 = 3
// f(123) -> 3 + 3 = 6
// f(1234) -> 6 + 4 = 10

// рекурсивный метод позволяет сэкономить время работы программы, но затрачивает больше операт.памяти (тк сохраняет каждую версию)
// итеративный метод позволяет сэкономить операт.память, но время для работы больше
// например, рекурсивный метод не используют в микропроцессорах по этой причине
// в рекурсии холостых ходов нет, а например, пузырьковая сортировка имеет много холостых ходов 
// ! один вариант рекурсии должен всегда приводить к ее завершению
// ПОЧИТАТЬ: алгоритм сортировки слиянием и алгоритм быстрой сортировки


// Task 03

// Задайте значения М и N. Напишите программу, которая выведет все натуральныне числа в промежутке от М до N

/*
void NumInterval(int numM, int numN)
{
    if(numM < numN)
    {
        Console.Write(numM + " ");
        NumInterval(numM + 1, numN);
    }
    if(numM > numN)
    {
        Console.Write(numM + " ");
        NumInterval(numM - 1, numN);
    }
    if (numM == numN) Console.WriteLine(numM);
}

// int m = Convert.ToInt32(Console.ReadLine());  // !!! ПОСЛЕ ЭТИХ СТРОК DOTNET RUN ЗАВИСАЕТ, КУРСОР ВНИЗУ, 
// int n = Convert.ToInt32(Console.ReadLine());  // ИСПРАВИТЬ: ПРЯМО ТАМ НУЖНО ВВЕСТИ CLEAR И ENTER
NumInterval(2,6);                             // зависание возникла потому, что в NumInterval(m,n) <- он не понял, где числа
*/



// Task 04

// Напишите программу, которая на входе принимает два числа А и В и возводит число А в степень В

/*
int Multy (int A, int B)
{
    if (B > 0) return Multy(A, B - 1) * A;
    return 1;
}

Console.WriteLine(Multy (5, 3));
*/


// Если степень м.б. отрицательной, то метод ! double    5(-3) <-это одна пятая в степ.3, 3(-2) <-одна третья в степ.2 

/*
double Multy (int A, int B)
{
    if (B > 0) return Multy(A, B - 1) * A;
    if (B < 0) return Multy(A, B + 1) / A;
    return 1;
}

Console.WriteLine(Multy (2, -2));
*/




// HomeWork_Seminar_09




// Task 64
// Задайте значение N. Напишите программу, которая выведет все натуральные числа в промежутке от N до 1.
// N = 5 -> "5, 4, 3, 2, 1"     ||   N = 8 -> "8, 7, 6, 5, 4, 3, 2, 1"

/*
void ShowNum(int num)               
{                                    
    Console.Write(num + " ");     
    if(num > 1) ShowNum(num - 1);              
}

Console.Write("Input the number: ");
int N = Convert.ToInt32(Console.ReadLine());

ShowNum(N);
*/




// Task 66: 
// Задайте значения M и N. Напишите программу, которая найдёт сумму натуральных элементов в промежутке от M до N.
// M = 1; N = 15 -> 120       ||      M = 4; N = 8. -> 30

/*
int SumNumbers(int M, int N)
{
    if (M == N) return N;     
    else if (M < N) return N + SumNumbers(M, N - 1); 
    else return N + SumNumbers(M, N + 1);                      
}
        
Console.Write("Input the number M: ");
int M = Convert.ToInt32(Console.ReadLine());
Console.Write("Input the number N: ");
int N = Convert.ToInt32(Console.ReadLine());
Console.WriteLine();
Console.WriteLine($"Sum of numbers from M to N is {SumNumbers(M, N)}");
Console.WriteLine();
*/
